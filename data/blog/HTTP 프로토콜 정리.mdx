---
title: HTTP 기초
date: '2023-01-08'
tags: ['HTTP']
draft: false
summary: 'HTTP를 리마인드하며 버전 별 기능과 히스토리에 대해 알아봅니다.'
---

## 목적

- HTTP 프로토콜에 대한 이해
- HTTP 프로토콜 메시지에 대한 이해

## HTTP란 무엇일까?

HTTP는 **HyperText Transfer Protocol**의 약자입니다. 풀어 말하면 `텍스트 이상의 무언가를 교환하는 통신규약` 이라고 말할 수 있다.  
여기서 `텍스트 이상의 무언가`는 데이터라고 명칭하며, HTTP는 웹에서 이루어지는 모든 데이터 교환의 기초이자, `클라이언트-서버 프로토콜`이기도 하다.

### 클라이언트-서버 프로토콜

클라이언트-서버 프로토콜이란, 클라이언트 측에 의해서 요청이 초기화되는 것을 말한다.  
여기서 클라이언트란 웹 브라우저라고 할 수 있는데, 웹 브라우저는 서버로부터 데이터를 수신하지만, 맨 처음 요청을 초기화하는 역할도 담당한다.
클라이언트와 서버는 개별적인 메시지 교환으로 통신한다.

- 클라이언트가 서버로 전송하는 메시지는 요청(requests)이라 합니다.
- 서버가 클라이언트로 전송하는 메시지를 응답(responses)라고 합니다.

## HTTP의 기초

### 간단하다.

HTTP는 사람이 읽을 수 있으며, 간단하게 만들어졌기 때문에 테스트하기 쉽고, 초심자가 배우기 쉽다.

### 확장 가능하다.

클라이언트와 서버가 헤더의 문법에 대해 간단한 합의만 한다면 언제는 새로운 기능을 추가할 수 있다.  
[nginx](http://github.com)의 `X-Forwarded-For` 속성이 적절한 사례입니다.

### 상태를 저장하지 않는다.

동일한 연결 상에서 전달된 연속된 두 요청은 아무 연결고리가 없습니다만, 이는 이커머스 쇼핑 바구니나, 사용자 별로 일관된 경험을 제공하는데 문제를 야기하지만, HTTP 쿠키를 사용해 세션을 만들어 해결할 수 있다.

### HTTP의 연결

연결은 OSI 7계층 중 전송 계층에서 담당하기 때문에 응용 계층인 HTTP 프로토콜에서 제어할 수 없다. HTTP는 근본적으로 어떤 특정 전송 프로토콜을 요구하지 않는 대신, 신뢰할 수 있거나 메세지 손실이 없는 연결을 요구할 뿐이다. 이는 일반적인 전송 프로토콜인 TCP와 UDP 중 신뢰할 수 있는 TCP를 말한다. HTTP/1.0은 매 요청/응답마다 별도의 TCP 연결을 열었지만, 이 동작은 버전이 업그레이드 되면서 개선되었다. 이후에 더 자세하게 살펴봐야 하지만 간단하게 개선 히스토리를 보자면 이렇다.

- 1.1 - 파이프라이닝과 지속적인 연결 개념 도입, `Connection` 헤더를 사용해 부분적으로 제어

  > 💡 `Connection` 헤더는 현재의 전송이 완료된 후 네트워크 접속을 유지할지 말지 결정한다. 전송된 값이 `keep-alive`면 연결은 지속되고 끊기지 않는다. `close`일 경우 연결을 닫는다. HTTP/1.0의 기본 값이다.

  > 💡 `Keep-Alive` 헤더에는 송신사가 연결에 대한 타임아웃과 요청 최대 개수을 어떻게 설정했는지에 대한 정보가 담겨 있다.

  > ```
  > HTTP/1.1 200 OK
  > Connection: Keep-Alive
  > Content-Encoding: gzip
  > Content-Type: text/html; charset=utf-8
  > Date: Thu, 11 Aug 2016 15:23:13 GMT
  > Keep-Alive: timeout=5, max=1000
  > Last-Modified: Mon, 25 Jul 2016 04:32:39 GMT
  > Server: Apache
  >
  >
  > (body)
  > ```

  > 💡HTTP 파이프라이닝이 활성화되면, 첫번째 요청에 대한 응답을 기다리지 않고 여러 요청을 보낼 수 있다.

  > | ![HTTP 파이프라이닝](https://developer.mozilla.org/en-US/docs/Web/HTTP/Connection_management_in_HTTP_1.x/http1_x_connections.png) |
  > | :-------------------------------------------------------------------------------------------------------------------------------: |
  > |          파이프라이닝<sub>[출처](https://developer.mozilla.org/ko/docs/Web/HTTP/Connection_management_in_HTTP_1.x)</sub>          |

- 2.0 - 단일 연경 상에서 메시지 다중전송 구현
  > 💡HTTP/1.1에 도입된 파이프라이닝의 경우, 구식 소프트웨어와 최신 버전이 공존하는 현재 네트워크 상에서는 구현하기 어렵다는게 입증되어, HTTP/2로 교체되고 있다.

## HTTP의 흐름

클라이언트가 서버와 통신하고자 할 때, 다음 과정을 거친다.

1.  TCP 연결을 연다. 클라이언트는 새 연결을 열거나, 기존 연결을 재사용하거나, 여러 TCP 연결을 열 수 있다.
2.  HTTP 메시지를 전송한다. 이는 사람이 읽을 수 있는 형태다. HTTP/2의 경우는 이런 메시지들이 프레임 속에 캡슐화되어 읽는게 불가능하지만 원칙은 동일하다.

    ```
    GET / HTTP/1.1
    Host: developer.mozilla.org
    Accept-Language: fr
    ```

3.  서버의 응답을 읽는다.

    ```
    HTTP/1.1 200 OK
    Date: Sat, 09 Oct 2010 14:28:02 GMT
    Server: Apache
    Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
    ETag: "51142bc1-7449-479b075b2891b"
    Accept-Ranges: bytes
    Content-Length: 29769
    Content-Type: text/html

    <!DOCTYPE html... (here comes the 29769 bytes of the requested web page)
    ```

4.  응답을 닫거나 다른 요청을 위해 재사용한다.

## HTTP 메시지

HTTP/1.1 까지의 초기 메시지는 사람이 읽을 수 있었으나, HTTP/2 부터는 이진 구조의 프레임안에 포함되어 헤더의 압축과 다중화 같은 최적화를 가능하게 했다. 클라이언ㅌ는 각 메시지들을 HTTP/1.1 요청으로 재구성하여 HTTP/1.1 포맷은 HTTP/2 에서도 여전히 유효하다. HTTP 메시지는 다음 두가지가 있으며, 각자의 특성이 있다.

### 요청

- 메서드

  클라이언트가 수행하고자 하는 동적을 정의한 POST, GET 같은 동사나, OPTIONS, HEAD와 같은 명사가 들어간다. 자원을 가져오거나 폼데이터를 전송할 때 구분지어 사용한다.

- 경로

  가져오려는 자원의 경로

- HTTP 버전
- 헤더

  서버에 대한 추가 정보를 담은 헤더들

- 바디

형태는 다음과 같으며

```
[메소드] [경로] [HTTP 프로토콜 버전]
[헤더]

[바디]
```

예시는 다음과 같다.

```
GET /ko/docs/Web/HTTP/Oveview HTTP/1.1
Host: developer.mozilla.org
```

### 응답

- HTTP 버전
- 요청의 성공 여부, 그 이유를 나타내는 상태 코드
- 상태 메시지
- 헤더
- 바디

형태는 다음과 같으며

```
[HTTP 프로토콜 버전] [상태 코드] [상태 메시지]
[헤더]

[바디]
```

예시는 다음과 같다.

```
HTTP/1.1 200 OK
Host:developer.mozilla.org

(body)
```

### 결론

HTTP는 사용이 쉬우며, 확장이 가능하기 때문에 웹과 함께 발전해온 것 같다. HTTP 버전이 오르면서 비효율적인 연결 과정을 꾸준히 개선해온 것으로 아는데, 다음 포스트에서는 HTTP가 어떻게 개선했는지에 대해 오늘 이해한 기초 지식을 기반으로 이해하고 정리할 생각이다.
